name: Deploy to Akash

# IMPORTANT SSL NOTE:
# ====================
# Akash providers use DNS-01 Let's Encrypt challenges with wildcard certs
# for their own domains (e.g., *.europlots.com). They CANNOT provision certs
# for custom domains (auth.alternatefutures.ai) because DNS-01 requires
# control over the domain's DNS records.
#
# SOLUTION: Deploy the Caddy SSL proxy (see deploy-caddy-proxy.yml) on Fly.io
# which handles HTTP-01 challenges for custom domains. The proxy then routes
# traffic to the Akash backend via the provider's ingress URL.
#
# Architecture:
#   User → auth.alternatefutures.ai (DNS → Fly.io)
#        → Caddy proxy (handles SSL via HTTP-01)
#        → Akash backend via provider ingress URL
#
# After deploying this workflow, update the Caddy proxy's AUTH_BACKEND
# environment variable with the new ingress URL.

on:
  # CHANGED: Manual-only deployment to prevent auto-deployments
  # This workflow creates a NEW deployment with a NEW DSEQ, requiring DNS updates.
  # Previously triggered by docker build completion - now manual only for safety.
  workflow_dispatch:
    inputs:
      confirm_deployment:
        description: 'I understand this creates a new DSEQ and may require DNS update'
        required: true
        default: false
        type: boolean

env:
  AKASH_NODE: https://rpc.akashnet.net:443
  AKASH_CHAIN_ID: akashnet-2
  AKASH_GAS_PRICES: 0.025uakt
  AKASH_GAS_ADJUSTMENT: "1.5"
  # Provider selection
  # IMPORTANT: Do NOT deploy on the same provider as the SSL proxy to avoid NAT hairpin issues.
  # The proxy cannot reach services on its own provider's public ingress.
  # Current proxy provider (blocked): akash18ga02jzaq8cw52anyhzkwta5wygufgu6zsz6xc (Europlots)
  # See: admin/infrastructure/deployments.ts for current proxy provider
  BLOCKED_PROVIDER: "akash18ga02jzaq8cw52anyhzkwta5wygufgu6zsz6xc"
  PREFERRED_PROVIDER: ""  # Will be selected from bids, excluding blocked provider

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Validate deployment confirmation
        if: ${{ inputs.confirm_deployment != true }}
        run: |
          echo "::error::You must confirm you understand this creates a new DSEQ"
          echo ""
          echo "This workflow creates a FULL REDEPLOY with a new DSEQ."
          echo "After deployment, you may need to update DNS records or proxy backends."
          exit 1

  deploy:
    needs: validate
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Akash CLI
        run: |
          # Install akash node CLI
          curl -sSfL https://raw.githubusercontent.com/akash-network/node/master/install.sh | sh -s -- -b /usr/local/bin
          akash version

          # Install provider-services CLI
          PROVIDER_VERSION=$(curl -s https://api.github.com/repos/akash-network/provider/releases/latest | jq -r '.tag_name')
          echo "Installing provider-services $PROVIDER_VERSION"
          curl -sSfL "https://github.com/akash-network/provider/releases/download/${PROVIDER_VERSION}/provider-services_linux_amd64.zip" -o /tmp/provider.zip
          unzip -o /tmp/provider.zip -d /usr/local/bin/
          chmod +x /usr/local/bin/provider-services

      - name: Setup Akash Wallet
        run: |
          mkdir -p $HOME/.akash
          echo "${{ secrets.AKASH_MNEMONIC }}" | akash keys add deployer --recover --keyring-backend=test --home $HOME/.akash
          export AKASH_FROM=$(akash keys show deployer -a --keyring-backend=test --home $HOME/.akash)
          echo "AKASH_FROM=$AKASH_FROM" >> $GITHUB_ENV
          echo "AKASH_HOME=$HOME/.akash" >> $GITHUB_ENV
          echo "Wallet address: $AKASH_FROM"

      - name: Setup Certificate
        run: |
          echo "Creating certificate for provider communication..."

          # Generate and broadcast certificate in one step
          akash tx cert generate client \
            --from deployer \
            --keyring-backend=test \
            --home $AKASH_HOME

          # Check if cert file exists
          ls -la $AKASH_HOME/

          if [ -f "$AKASH_HOME/$AKASH_FROM.pem" ]; then
            echo "Certificate file generated at $AKASH_HOME/$AKASH_FROM.pem"
          else
            echo "ERROR: Certificate file not found!"
            exit 1
          fi

          # Publish certificate to chain
          akash tx cert publish client \
            --from deployer \
            --keyring-backend=test \
            --home $AKASH_HOME \
            --yes \
            --gas-prices $AKASH_GAS_PRICES \
            --gas auto \
            --gas-adjustment $AKASH_GAS_ADJUSTMENT || echo "Certificate may already be published"

          sleep 10
          echo "Certificate setup complete"

      - name: Get Image Tag
        run: |
          # Use SHA-based tag to ensure we always pull fresh image
          SHORT_SHA="${GITHUB_SHA::7}"
          IMAGE_TAG="main-${SHORT_SHA}"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Using image tag: $IMAGE_TAG"

      - name: Prepare SDL
        run: |
          # Create deployment SDL with secrets substituted
          cat > /tmp/deploy.yaml << EOF
          ---
          version: "2.0"

          services:
            auth-api:
              image: ghcr.io/alternatefutures/service-auth:${IMAGE_TAG}
              credentials:
                host: ghcr.io
                username: alternatefutures
                password: "${{ secrets.GHCR_PAT }}"
              expose:
                - port: 3000
                  as: 80
                  to:
                    - global: true
                  accept:
                    - auth.alternatefutures.ai
              env:
                # Core Configuration
                - NODE_ENV=production
                - PORT=3000
                # DATABASE_URL is fetched from Infisical at runtime (PostgreSQL connection)
                # Format: postgresql://user:password@host:5432/database
                - JWT_EXPIRES_IN=15m
                - JWT_REFRESH_EXPIRES_IN=7d
                - DOMAIN=alternatefutures.ai
                - APP_URL=https://auth.alternatefutures.ai
                - FRONTEND_URL=https://app.alternatefutures.ai
                - CORS_ORIGIN=https://app.alternatefutures.ai
                - GOOGLE_REDIRECT_URI=https://auth.alternatefutures.ai/auth/oauth/callback/google
                - GITHUB_REDIRECT_URI=https://auth.alternatefutures.ai/auth/oauth/callback/github
                - TWITTER_REDIRECT_URI=https://auth.alternatefutures.ai/auth/oauth/callback/twitter
                - DISCORD_REDIRECT_URI=https://auth.alternatefutures.ai/auth/oauth/callback/discord
                - INFISICAL_SITE_URL=https://secrets.alternatefutures.ai
                - INFISICAL_CLIENT_ID=${{ secrets.INFISICAL_CLIENT_ID }}
                - INFISICAL_CLIENT_SECRET=${{ secrets.INFISICAL_CLIENT_SECRET }}
                - INFISICAL_PROJECT_ID=${{ secrets.INFISICAL_PROJECT_ID }}
                - INFISICAL_GLOBAL_PROJECT_ID=${{ secrets.INFISICAL_GLOBAL_PROJECT_ID }}
                - INFISICAL_ENVIRONMENT=prod

          profiles:
            compute:
              auth-api:
                resources:
                  cpu:
                    units: 1.0
                  memory:
                    size: 1Gi
                  storage:
                    - size: 1Gi

            placement:
              akash:
                attributes:
                  host: akash
                signedBy:
                  anyOf:
                    - "akash1365yvmc4s7awdyj3n2sav7xfx76adc6dnmlx63"
                pricing:
                  auth-api:
                    denom: uakt
                    amount: 100

          deployment:
            auth-api:
              akash:
                profile: auth-api
                count: 1
          EOF

          echo "SDL prepared"
          cat /tmp/deploy.yaml

      - name: Create Deployment
        id: create
        run: |
          echo "Creating new deployment..."

          # Create deployment and capture transaction
          akash tx deployment create /tmp/deploy.yaml \
            --from deployer \
            --keyring-backend=test \
            --home $AKASH_HOME \
            --yes \
            --gas-prices $AKASH_GAS_PRICES \
            --gas auto \
            --gas-adjustment $AKASH_GAS_ADJUSTMENT \
            --output json > /tmp/tx-result.json 2>&1 || true

          cat /tmp/tx-result.json

          # Wait for transaction to be included
          sleep 15

          # Extract DSEQ from transaction result (more reliable than querying deployments)
          echo "Extracting DSEQ from transaction result..."

          # The dseq is nested inside the "id" attribute as a JSON string
          # Event type: akash.deployment.v1.EventDeploymentCreated
          DSEQ=$(cat /tmp/tx-result.json | jq -r '
            .events[] |
            select(.type=="akash.deployment.v1.EventDeploymentCreated") |
            .attributes[] |
            select(.key=="id") |
            .value | fromjson | .dseq' 2>/dev/null)

          # Fallback: query deployments and get highest DSEQ (newest)
          if [ "$DSEQ" = "null" ] || [ -z "$DSEQ" ]; then
            echo "Could not extract from tx result, querying deployments..."
            akash query deployment list \
              --owner $AKASH_FROM \
              --output json > /tmp/deployments.json

            # Sort by DSEQ descending to get the newest
            DSEQ=$(cat /tmp/deployments.json | jq -r '
              .deployments |
              sort_by(.deployment.id.dseq | tonumber) |
              reverse |
              .[0].deployment.id.dseq')
          fi

          if [ "$DSEQ" = "null" ] || [ -z "$DSEQ" ]; then
            echo "ERROR: Could not extract DSEQ"
            cat /tmp/tx-result.json
            exit 1
          fi

          echo "New DSEQ: $DSEQ"
          echo "DSEQ=$DSEQ" >> $GITHUB_ENV

      - name: Wait for Bids and Select Provider
        run: |
          echo "Waiting for bids on DSEQ: $DSEQ"
          sleep 30

          # List all bids
          akash query market bid list \
            --owner $AKASH_FROM \
            --dseq $DSEQ \
            --output json > /tmp/bids.json

          # Debug: show raw JSON structure
          echo "Raw bids structure (first bid):"
          cat /tmp/bids.json | jq '.bids[0]' 2>/dev/null || echo "No bids found"

          echo ""
          echo "All bids received:"
          # Handle different JSON structures: .bid.id.provider (actual) vs .bid.bid_id.provider (legacy)
          cat /tmp/bids.json | jq '.bids[] | {provider: (.bid.id.provider // .bid.bid_id.provider // .bidId.provider), price: (.bid.price.amount // .price.amount)}'

          # Filter out blocked provider (SSL proxy's provider - NAT hairpin issue)
          echo ""
          echo "Filtering out blocked provider: $BLOCKED_PROVIDER"
          echo "Reason: SSL proxy is on this provider - NAT hairpin prevents connectivity"

          # Extract providers - actual path is .bid.id.provider
          SAFE_PROVIDERS=$(cat /tmp/bids.json | jq -r --arg blocked "$BLOCKED_PROVIDER" '
            .bids[] |
            ((.bid.id.provider // .bid.bid_id.provider // .bidId.provider) | select(. != null)) as $provider |
            select($provider != $blocked) |
            $provider
          ')

          echo "Safe providers found:"
          echo "$SAFE_PROVIDERS"

          if [ -z "$SAFE_PROVIDERS" ]; then
            echo "::error::No safe providers available! All bids are from the blocked provider."
            echo "Either wait for more bids or move the SSL proxy to a different provider."
            echo ""
            echo "Debug: Checking if any providers exist at all..."
            cat /tmp/bids.json | jq -r '.bids[] | (.bid.id.provider // .bid.bid_id.provider // .bidId.provider // "NO_PROVIDER_FOUND")'
            exit 1
          fi

          # Select the first safe provider (could enhance to select cheapest)
          SELECTED_PROVIDER=$(echo "$SAFE_PROVIDERS" | head -n1)
          echo "Selected safe provider: $SELECTED_PROVIDER"
          echo "SELECTED_PROVIDER=$SELECTED_PROVIDER" >> $GITHUB_ENV

      - name: Accept Bid from Safe Provider
        run: |
          echo "Accepting bid from provider: $SELECTED_PROVIDER"
          echo "(Blocked provider $BLOCKED_PROVIDER was excluded to avoid NAT hairpin)"

          # Create lease with selected safe provider
          akash tx market lease create \
            --dseq $DSEQ \
            --provider $SELECTED_PROVIDER \
            --from deployer \
            --keyring-backend=test \
            --home $AKASH_HOME \
            --yes \
            --gas-prices $AKASH_GAS_PRICES \
            --gas auto \
            --gas-adjustment $AKASH_GAS_ADJUSTMENT

          sleep 10
          echo "Lease created with provider: $SELECTED_PROVIDER"

      - name: Send Manifest
        run: |
          echo "Sending manifest to provider: $SELECTED_PROVIDER"

          provider-services send-manifest /tmp/deploy.yaml \
            --dseq $DSEQ \
            --provider $SELECTED_PROVIDER \
            --from deployer \
            --keyring-backend=test \
            --home $AKASH_HOME

          echo "Manifest sent"

      - name: Get Ingress URL
        run: |
          echo "Waiting for service to be ready..."
          sleep 60

          # Get the new ingress URL from the provider
          INGRESS=$(provider-services lease-status \
            --dseq $DSEQ \
            --provider $SELECTED_PROVIDER \
            --from deployer \
            --keyring-backend=test \
            --home $AKASH_HOME 2>/dev/null | jq -r '.services["auth-api"].uris[0]' || echo "")

          if [ -n "$INGRESS" ]; then
            echo "New ingress URL: $INGRESS"
            echo "INGRESS=$INGRESS" >> $GITHUB_ENV
          fi

      - name: Update SSL Proxy Backend
        if: env.INGRESS != ''
        run: |
          echo "=== IMPORTANT: Update Caddy SSL Proxy ==="
          echo ""
          echo "The auth service backend is now available at:"
          echo "  $INGRESS"
          echo ""
          echo "To update the SSL proxy (Fly.io), run:"
          echo "  flyctl secrets set AUTH_BACKEND=$INGRESS -a alternatefutures-proxy"
          echo ""
          echo "Or trigger the deploy-caddy-proxy workflow with updated secrets."
          echo ""
          echo "The custom domain auth.alternatefutures.ai DNS should point to"
          echo "the Fly.io proxy, NOT directly to Akash."

      - name: Deployment Summary
        run: |
          echo "## Akash Deployment Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**DSEQ**: \`$DSEQ\`" >> $GITHUB_STEP_SUMMARY
          echo "**Provider**: \`$SELECTED_PROVIDER\`" >> $GITHUB_STEP_SUMMARY
          echo "**Blocked Provider**: \`$BLOCKED_PROVIDER\` (SSL proxy - NAT hairpin)" >> $GITHUB_STEP_SUMMARY
          if [ -n "$INGRESS" ]; then
            echo "**Backend Ingress**: \`$INGRESS\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### SSL Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The custom domain \`auth.alternatefutures.ai\` uses the Caddy SSL proxy" >> $GITHUB_STEP_SUMMARY
          echo "deployed on Fly.io for automatic Let's Encrypt certificates." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Update Fly.io proxy backend: \`flyctl secrets set AUTH_BACKEND=$INGRESS -a alternatefutures-proxy\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Ensure DNS for \`auth.alternatefutures.ai\` points to Fly.io proxy" >> $GITHUB_STEP_SUMMARY
          echo "3. Close old Akash deployments to save AKT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "⚠️ **Note**: Update DEPLOYMENTS.md in the .github repo with new DSEQ" >> $GITHUB_STEP_SUMMARY
